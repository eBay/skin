<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skeleton Examples : eBay Skin</title>
    <style>
        hr {
            border: 1px solid #ccc;
            margin: 1em 0;
        }
    </style>
</head>

<body>
    <p>This page details <a href="#techniques">implementation techniques</a> and <a href="#scenarios">common loading scenarios</a> for eBay Skin's <a href="../index.html#skeleton">skeleton</a> module.</p>
    <p><strong>NOTE:</strong> This page demonstrates both good and bad uses of skeletons; please be sure to read and understand carefully to avoid replicating an anti-pattern!</p>

    <hr />

    <h2 id="techniques">Techniques</h2>
    <p>Skeletons can be used as placeholders for content using either a pure CSS approach, or a DOM manipulation approach with JavaScript.</p>

    <h3 id="techniques-css">Technique 1: Pure CSS</h3>
    <p>This technique leverages the CSS <span class="highlight">:empty</span> pseudo-class, as documented in the article, <a href="https://dev.to/tigt/skeleton-screens-but-fast-48f1">"Skeleton screens, but fast"</a> by Taylor Hunt. This approach is highly performant, especially on devices with limited CPU resources.</p>
    <p>If an element is empty, then its <span class="highlight">:empty</span> selector matches, and the associated styles (i.e. the skeleton graphics) are applied. When the content is rendered, <span class="highlight">:empty</span> no longer matches, and the styles (our skeleton graphics) are removed. Marvellous!</p>
    <p>The HTML would look like this:</p>
    {% highlight html %}  
<div class="search-results-skeleton" role="img" aria-label="loading">
    <!-- this element will match :empty until content is inserted -->
</div>
    {% endhighlight %}

    <p>The CSS selector like so:</p>

    {% highlight css %}
.search-results-skeleton:empty {
    /* app developer must write CSS to create skeleton graphics */
}
    {% endhighlight %}

    <p><strong>NOTE:</strong> The <span class="highlight">:empty</span> pseudo-class considers elements with whitespace as not empty!</p>
    <p>The downside is that our <a href="../index.html#skeleton">skeleton classes</a> cannot be leveraged (in theory, LESS mixins could be provided) and <em>composite</em> skeletons (e.g. items tiles) may require some non-trivial use of CSS linear gradients for certain skeletons.</p>
    <p>A second potential downside is that these styles will be painted immediately by the browser, resulting in a quick flash of skeletons if the content or action is quick to resolve (say under 500ms or so).</p>
    
    <hr />

    <h3 id="techniques-javascript">Technique 2: JavaScript</h3>
    <p>With JavaScript, we gain more flexibility and control over when and how the skeleton placeholder is replaced with the actual content. We can either remove the the skeleton node from the DOM, as shown below.</p>

    {% highlight html %}
<!-- Before -->
<div class="skeleton" role="img" aria-label="loading" style="width: 200px;">
    <div class="skeleton__button"></div>
</div>

<!-- After -->
<div>
    <p>content</p>
</div>
{% endhighlight %}

<p>Or we can simply hide the skeleton.</p>

{% highlight html %}
<!-- Before -->
<div class="skeleton" role="img" aria-label="loading" style="width: 200px;">
    <div class="skeleton__button"></div>
</div>

<!-- After -->
<div class="skeleton" role="img" aria-label="loading" style="width: 200px;" hidden>
    <div class="skeleton__button"></div>
</div>
<div>
    <p>content</p>
</div>
{% endhighlight %}

    <hr />

    <h2 id="scenarios">Page Loading Scenarios</h2>
    <p>For the purposes of keeping examples simple, we use a basic blog template for conveying common loading techniques. In reality, blog pages are typically static (therefore cached and highly performant) and would not require skeletons. Please keep this in mind and think very carefully about whether your type of page and architecture actually requires the technical overhead of skeletons or not.</p>

    <p>We consider 4 main scenarios for how a full page may be constructed:</p>
    <ol>
        <li>Buffered (default)</li>
        <li>Client-Side Rendered (SPA)</li>
        <li>In-Order Streaming (Progressive Rendering)</li>
        <li>Out of Order Streaming (requires framework)</li>
    </ol>

    <p>Of course after the page is loaded and rendered is only part of the story! User interface components may also trigger <a href="#scenario-5">partial page updates</a>, in which case skeleton placeholders may also be utilized.</p>

    <h3 id="scenario-1">Scenario 1: Buffered Rendering</h3>
    <p>With buffered rendering (the default manner in which web pages are loaded) the client waits for the entire HTML to be sent by the server before rendering. Therefore, in this scenario, there is no opportunity to display skeleton placeholders, because the content arrives all at once (one caveat would be a SPA, which we cover in the next section).</p>

    <h4>Example 1A - The White Screen</h4>
    <p>This example simulates the delay (set to 3 seconds) and white screen while the client waits for the entire HTML payload from the server.</p>
    <p><a href="./buffered/example-1/">View Example 1A</a></p>

    <hr />

    <h3 id="scenario-2">Scenario 2: Client Side Rendering (SPA)</h3>
    <p>A buffered page load can however be the starting point for a non-isomorphic client-side app, i.e. if the server sends a single script tag as the app entry point. The JavaScript app could then leverage skeletons as content placeholders.</p>
    <p>Fully client-side rendered JavaScript applications (i.e. SPAs) such as this are currently out of scope for this documentation. We may add updates in the future. In general though, many of the concepts of <a href="#scenario-4">out-of-order streaming</a> will apply.</p>

    <hr />

    <h3 id="scenario-3">Scenario 3: In-Order Streaming (Progressive Rendering)</h3>
    <p>In contrast to buffered rendering, progressive rendering does not have to wait for the entire HTML to arrive from the server. The client receives the HTML in chunks, allowing critical above-the-fold content to be displayed first, meaning less time staring at an empty white screen.</p>
    <p>The CSS <span class="highlight">:empty</span> technique is highly efficient for this scenario. Remember however, that our Skin skeleton classes cannot be leveraged with this technique; therefore the developer must construct skeletons with their own custom CSS.</p>
    <p>In all examples below we utilize client-side JavaScript to simulate how a server might stream the HTML in chunks to the client.</p>

    <h4>Example 3A - One Column and White Space</h4>
    <p>Our first progressive rendering example shows how the main article content might be streamed in after the main navigation and featured articles.</p>
    <p><a href="./in-order/example-1/">View Example 3A</a></p>
    <p>We have added a 3 second delay in order to simulate a service that is slow to fetch the main content. Remember, this is a highly contrived use case! No web site should be taking that long to retrieve static content and therefore would never require a skeleton!</p>

    <h4>Example 3B - One Column with Skeleton</h4>
    <p>Now let's add a skeleton placeholder for the main content. Using progressive rendering we stream an opening div tag to the client, and while the server works on getting the next chunk ready, the element will match the CSS :empty rule.</p>
    <p><a href="./in-order/example-3/">View Example 3B</a></p>
    <p>Okay, that was easy, our white space has been replaced with a skeleton while we wait for the next chunk to arrive. But what about when we have two columns?</p>

    <h4>Example 3C - Two Columns with Single Skeleton</h4>
    <p>With in-order streaming we can open an HTML tag, leave it open (until the next flush) and it will satisfy the :empty selector. However, our main column and side column are siblings elements, so we cannot start the side column element without closing the main column element. This means we cannot have an :empty main column and an :empty side column at the same time.</p>
    <p>One approach might be to just send the both left and right column content in the same chunk, meaning we can construct just a single skeleton that displays two columns.</p>
    <p><a href="./in-order/example-4/">View Example 3C</a></p>
    <p>This might be satisfactory in some cases, but what if the service for the side column is also slow? What if we want to show the main column content sooner and send that chunk as soon as we get it? Also, What about responsive design? How will the two column skeleton respond at various breakpoints? At this point we start to see that the choreographing of skeletons with in-order streaming and a pure CSS approach is becoming stretched to its limits. </p>

    <h4>Example 3D - Two Columns with Two Skeletons</h4>
    <p>We <em>could</em> utlize the "two column layout" graphic from the previous example, and as soon as the content for the main column flushes, start a new empty element (with skeleton) for the side column.</p>
    <p><a href="./in-order/example-5/">View Example 3D</a></p>
    <p>This helps with regards to showing the main content sooner, but we have now increased our technical overhead in terms of both the the choreography <em>and</em> responsive design.</p>
    <p>If we have more than one slow service, it might be time to think about out-of-order streaming, which can eliminate these choreography concerns, but on the flipside has the potential to introduce the dreaded layout shift.</p>
    
    <hr />

    <h3 id="scenario-4">Scenario 4: Out of Order Streaming</h3>
    <p>Out-of-order streaming allows chunks of page content to arrive in any order, e.g. the server could send the chunk for the side column before the chunk for the main column. This technique does require some client-side JavaScript to re-assemble the DOM in the correct order as pieces arrive.</p>
    <p>Out-of-order streaming does have some parallels with client-side rendered SPAs, as those apps might typically render content based on the order in which their fetch requests come in.</p>
    <p>In all examples below we utilize client-side JavaScript to simulate an out-of-order streaming experience.</p>

    <h4>Example 4A - Layout Shift</h4>
    <p>With our in-order streaming examples, the appereance of new content was always <em>appended</em>, therefore never caused existing content or layout to move. Let's see what happens when we stream in 3 sections of content in any order.</p>
    <p><a href="./out-of-order/example-0/">View Example 4A</a></p>
    <p>As the content is loading, try clicking on the link in the footer. Now imagine if it were an "Add to Cart" or "Buy Now" button and how infuriating that would be. Imagine being a keyboard user, and the element you have focus on disappearing from view.</p>
    <p>So, while getting content to the user faster always sounds like a good idea in theory, this example showcases how it can cause some unintended consequences and a very poor UX. The good news is that skeletons, under certain conditions, have the ability to mitigate or mask entirely the problems associated with content arriving out-of-order.</p>
  
    <h4>Example 4B - Naive Skeletons</h4>
    <p>Let's take a quick, naive stab at adding skeletons as placeholders for this content.</p>
    <p><a href="./out-of-order/example-1/">View Example 4B</a></p>
    <p>This hasn't solved our problem. It has only made things worse. For example, the footer is initially pushed down below-the-fold due to the skeleton, then can jump above the fold, then can be pushed down again (good luck clicking that link!).</p>
    <p>It could be argued the skeletons at least give some affordance the layout is about to shift in <em>some</em> way. Which might lead the user to think, "I'm just not going to interact with this page until I'm sure it's all done!"; this is not good.</p>

    <h4>Example 4C - Smarter Skeletons</h4>
    <p>One of the conditions for a better skeleton UX is for the physical dimensions of the content to be known ahead of time. When skeletons reserve the right amount of space, they will prevent layout from shifting.</p>
    <p>For some kinds of content, we can be sure of the physical dimensions ahead of time, images, videos, carousels, for example. For text however, we can only approximate in most cases.</p>
    <p><a href="./out-of-order/example-2/">View Example 4B</a></p>
    <p>Can we ever guarantuee the physical dimensions of paragraphs of text? No. Resizing the browser in this example should demonstrate that layout shift will occur when dimensions do not match.</p>

    
        <div class="template--item">
            <div class="template--item_head">
                <h4>Example 3</h4>
                <div class="template--item_head_actions">
                    <a href="./out-of-order/example-3/">Open</a>
                </div>
            </div>
            <iframe src="./out-of-order/example-3/" frameborder="0"></iframe>
        </div>
        <div class="template--item">
            <div class="template--item_head">
                <h4>Example 4</h4>
                <div class="template--item_head_actions">
                    <a href="./out-of-order/example-4/">Open</a>
                </div>
            </div>
            <iframe src="./out-of-order/example-4/" frameborder="0"></iframe>
        </div>
        <div class="template--item">
            <div class="template--item_head">
                <h4>Example 5</h4>
                <div class="template--item_head_actions">
                    <a href="./out-of-order/example-5/">Open</a>
                </div>
            </div>
            <iframe src="./out-of-order/example-5/" frameborder="0"></iframe>
        </div>
    </div>

    <hr />

    <h3 id="scenario-5">Scenario 5: Partial Page Updates</h3>
    <p>Client-side rendering is a widely used technique in which JavaScript on the client's side is responsible for rendering skeletons and making API calls to retrieve data from the server. This data then replaces the skeleton screens. This approach requires JavaScript, making <a href="#implementation-2">implementation 2</a> the preferred choice.</p> 
    <p>The example 5 below illustrates a component that partially renders content from the server. It's linked with a "Load more Images" button that triggers a client-side request for additional data from the server. During this operation, skeletons are displayed. This example highlights how unpredictable content can lead to layout shifts, and how the example 6 uses ellipses to truncate content in an attempt to mitigate this issue.</p>
    <div class="template--tiles">
        <div class="template--item">
            <div class="template--item_head">
                <h4>Example 1</h4>
                <div class="template--item_head_actions">
                    <a href="./csr/example-1/">Open</a>
                </div>
            </div>
            <iframe src="./csr/example-1/" frameborder="0"></iframe>
        </div>
        <div class="template--item">
            <div class="template--item_head">
                <h4>Example 2</h4>
                <div class="template--item_head_actions">
                    <a href="./csr/example-2/">Open</a>
                </div>
            </div>
            <iframe src="./csr/example-2/" frameborder="0"></iframe>
        </div>
        <div class="template--item">
            <div class="template--item_head">
                <h4>Example 3</h4>
                <div class="template--item_head_actions">
                    <a href="./csr/example-3/">Open</a>
                </div>
            </div>
            <iframe src="./csr/example-3/" frameborder="0"></iframe>
        </div>
        <div class="template--item">
            <div class="template--item_head">
                <h4>Example 4</h4>
                <div class="template--item_head_actions">
                    <a href="./csr/example-4/">Open</a>
                </div>
            </div>
            <iframe src="./csr/example-4/" frameborder="0"></iframe>
        </div>
    </div>
</body>

</html>